// BUILD: 2026-02-16 ‚Äî cleaned + LIVE restored (banner-based), brief LIVE ping
// Cloudflare Worker ‚Äî Diablo 2 TZ tracker -> Discord
// KV binding: TZ_KV
// Secret (optional): DISCORD_WEBHOOK_URL  (may include ?thread_id=...)
// Text var (optional): DISCORD_ROLE_ID
// Cron: */5 * * * *

/* ========================================================================== */
/* ============================ SECTION: CONFIG START ======================== */
/* ========================================================================== */

// Discord policy
const DISCORD_ATTEMPTS   = 3;        // up to 3 tries per op
const DISCORD_TIMEOUT_MS = 10_000;   // per-call timeout

// Scraper
const SCRAPE_MAX_RETRIES = 4;
const SCRAPE_BASE_DELAY  = 400;      // ms base backoff (scraper only)
const SCRAPE_TIMEOUT_MS  = 12_000;   // per-call timeout
const SCRAPE_URL = "https://www.diablo2.io/tzonetracker.php";

// LIVE behavior
const LIVE_DELETE_GRACE_S = 90;

// Transient ping message (new message => real notification)
const KV_LAST_PING_ID     = "last_ping_message_id";
const KV_LAST_PING_EPOCH  = "last_ping_message_epoch";
const KV_PING_UP_LAST_ID    = "ping:up:last_id";
const KV_PING_UP_LAST_EPOCH = "ping:up:last_epoch";
const KV_PING_UP_STAGE      = "ping:up:stage";
const KV_PING_LIVE_LAST_ID  = "ping:live:last_id";
const KV_PING_LIVE_LAST_EPOCH = "ping:live:last_epoch";

const KV_PING_UP_EXPIRES      = "ping:up:expires";
const KV_PING_LIVE_EXPIRES    = "ping:live:expires";

// Track which canon we last pinged LIVE for (so LIVE pings are only on transitions)
const KV_PING_LIVE_CANON = "ping:live:canon";

// Optional: track which upcoming target we last *discovered* (canon + start epoch)
const KV_UP_CANON = "upcoming_zone_canon";
const KV_UP_DISPLAY = "upcoming_zone_display";
const KV_UP_START_EPOCH = "upcoming_start_epoch";
const PING_TTL_SECONDS = 6 * 60; // 6 minutes

// Persistent message slots
const KV_ANNOUNCE_ID = "persistent_announce_message_id"; // slot #1 (top)
const KV_INFO_ID     = "persistent_info_message_id";     // slot #2 (bottom)

/* ========================================================================== */
/* ============================= SECTION: CONFIG END ========================= */
/* ========================================================================== */


/* ========================================================================== */
/* ===================== SECTION: RUN GUARDS / IDEMPOTENCY START ============= */
/* ========================================================================== */

// Intra-run guard to prevent multiple helpers overwriting the same announcement banner.
function makeRunState() {
  return {
    patchedAnnouncement: false,
    announcementHash: null,
    announcementMode: null,
    setUpcomingThisRun: false,
    setLiveThisRun: false,
  };
}

// Small, fast non-crypto hash (FNV-1a-ish) for content de-dupe.
function simpleHash(str) {
  let h = 2166136261;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0).toString(16);
}

/**
 * Patch announcement slot with:
 *  - intra-run guard (prevents multiple overwrites within the same invocation)
 *  - cross-run hash de-dupe via KV (reduces churn + race surface)
 *
 * Uses KV keys:
 *   - announce_last_hash
 *   - announce_last_mode   ("dashboard" | "suppressed")
 */
async function patchAnnouncementOnce(env, runState, framedAnnouncement, mode = "unknown") {
  if (!runState) return patchAnnouncementSlot(env, framedAnnouncement);

  const h = simpleHash(String(framedAnnouncement ?? ""));

  // Same content already written this run
  if (runState.patchedAnnouncement && runState.announcementHash === h && runState.announcementMode === mode) {
    return;
  }

  // Cross-run de-dupe: only skip if BOTH hash and mode match.
  // (KV can be stale, so mode is the safety valve to prevent getting "stuck".)
  const [lastHash, lastMode] = await Promise.all([
    env.TZ_KV.get("announce_last_hash"),
    env.TZ_KV.get("announce_last_mode"),
  ]);

  if (lastHash && lastHash === h && lastMode && lastMode === mode) {
    runState.patchedAnnouncement = true;
    runState.announcementHash = h;
    runState.announcementMode = mode;
    return;
  }

  await patchAnnouncementSlot(env, framedAnnouncement);

  runState.patchedAnnouncement = true;
  runState.announcementHash = h;
  runState.announcementMode = mode;

  await Promise.all([
    env.TZ_KV.put("announce_last_hash", h),
    env.TZ_KV.put("announce_last_mode", mode),
  ]);
}

/**
 * Best-effort KV lock. Not perfect (KV is eventually consistent), but greatly
 * reduces duplicate recreates/overwrites from overlapping runs.
 */
async function withKvLock(kv, lockKey, ttlSeconds, fn) {
  const token = crypto.randomUUID();
  const now = Date.now();

  const existing = await kv.get(lockKey);
  if (existing) return { ok: false, reason: "locked" };

  await kv.put(lockKey, JSON.stringify({ token, at: now }), { expirationTtl: ttlSeconds });

  const check = await kv.get(lockKey);
  if (!check) return { ok: false, reason: "lost_lock" };

  try {
    const parsed = JSON.parse(check);
    if (!parsed || parsed.token !== token) return { ok: false, reason: "lost_lock" };
  } catch {
    return { ok: false, reason: "bad_lock" };
  }

  try {
    return { ok: true, result: await fn() };
  } finally {
    // release best-effort
    const finalCheck = await kv.get(lockKey);
    if (finalCheck) {
      try {
        const parsed = JSON.parse(finalCheck);
        if (parsed && parsed.token === token) await kv.delete(lockKey);
      } catch {}
    }
  }
}

/* ========================================================================== */
/* ===================== SECTION: RUN GUARDS / IDEMPOTENCY END =============== */
/* ========================================================================== */


/* ========================================================================== */
/* ====================== SECTION: WATCHLIST & THEMING START ================= */
/* ========================================================================== */

const WATCH_CANON_MAP = new Map([
  ["Worldstone Keep", "Baal"],
  ["Chaos Sanctuary", "Diablo"],
  ["The Secret Cow Level", "Moo Moo"],
  ["Cathedral", "Andy"],
  ["Tower Cellar", "The Countess"],
  ["Nihlathak", "Nithilak"],

  ["Tristram", "Tristram"],
  ["Dry Hills", "Cubed"],
  ["Lost City", "Lost City"],
  ["Arcane Sanctuary", "Sanctuary"],
  ["Tal Rasha's Tomb", "Duriel"],

  ["Flayer Jungle", "Lala Jungle"],
  ["Kurast Bazaar", "Kurast Tour"],
  ["Travincal", "Money Council"],
  ["Durance of Hate", "Meph"],

  ["Bloody Foothills", "Dodgeball"],
]);

const ZONE_THEME = {
  "Worldstone Keep":       { header: "‚öîÔ∏èüî•" },
  "Chaos Sanctuary":       { header: "üòàüî•" },
  "The Secret Cow Level":  { header: "üêÑü•õ" },
  "Cathedral":             { header: "üè∞üïØÔ∏è" },
  "Tower Cellar":          { header: "üóºüóùÔ∏è" },
  "Nihlathak":             { header: "üíÄ‚ùÑÔ∏è" },

  "Tristram":              { header: "ü¶µüî•" },
  "Dry Hills":             { header: "üßäüóÉÔ∏è" },
  "Lost City":             { header: "üèúÔ∏èü¶Ç" },
  "Arcane Sanctuary":      { header: "üåÄ‚ú®" },
  "Tal Rasha's Tomb":      { header: "üêõ‚ùÑÔ∏è" },

  "Flayer Jungle":         { header: "üåøüó°Ô∏è" },
  "Kurast Bazaar":         { header: "üõïüåø" },
  "Travincal":             { header: "üí∞üó°Ô∏è" },
  "Durance of Hate":       { header: "üåäüíÄ" },

  "Bloody Foothills":      { header: "üèîÔ∏èüèÉ" },
};

const GENERIC = { header: "‚öîÔ∏èüî•" };
const themed = (canon) => ZONE_THEME[canon] || GENERIC;


// Display name for a canon zone (group key). Tracked zones can override via WATCH_CANON_MAP.
function zoneDisplayForCanon(zoneCanon) {
  if (!zoneCanon) return null;
  return WATCH_CANON_MAP.get(zoneCanon) || zoneCanon;
}

const reverseEmojis = (s) => [...s].reverse().join("");

function displayFor(canon) {
  const v = WATCH_CANON_MAP.get(canon);
  return (v && v.trim()) ? v.trim() : canon;
}

/* ========================================================================== */
/* ======================= SECTION: WATCHLIST & THEMING END ================== */
/* ========================================================================== */


/* ========================================================================== */
/* =========================== SECTION: ZONE GROUPS START ==================== */
/* ========================================================================== */

const ZONE_GROUPS = [
  // Act 1
  ["Blood Moor", "Den of Evil"],  
  ["Cold Plains", "Cave"],
  ["Burial Grounds", "Crypt", "Mausoleum"],
  ["Stony Field", "Tristram" ],
  ["Dark Wood", "Underground Passage"],
  ["Black Marsh","Tower Cellar", "The Hole", "Forgotten Tower"],
  ["Jail", "Barracks"],
  ["Tamoe Highland", "The Pit", "Outer Cloister"],
  ["Cathedral", "Inner Cloister", "Catacombs"],
  ["The Secret Cow Level"],

  // Act 2
  ["The Sewers"],
  ["Rocky Waste", "Stony Tomb"],
  ["Dry Hills", "Halls of the Dead"],
  ["Far Oasis", "Maggot Lair"],
  ["Lost City", "Valley of Snakes", "Claw Viper Temple", "Ancient Tunnels"],
  ["Arcane Sanctuary", "Harem", "Palace"],
  ["Tal Rasha's Tomb", "Canyon of the Magi"],

  // Act 3
  ["Spider Forest", "Spider Cavern", "Arachnid Lair"],
  ["Great Marsh"],
  ["Flayer Jungle", "Flayer Dungeon", "Swampy Pit"],
  ["Kurast Bazaar", "Ruined Temple", "Disused Fane", "Lower Kurast", "Upper Kurast", "Forgotten Temple", "Forgotten Reliquary", "Disused Reliquary", "Ruined Fane"],
  ["Travincal"],
  ["Durance of Hate"],

  // Act 4
  ["Outer Steppes", "Plains of Despair"],
  ["River of Flame", "City of the Damned"],
  ["Chaos Sanctuary"],

  // Act 5
  ["Bloody Foothills", "Frigid Highlands", "Abaddon"],
  ["Glacial Trail", "Drifter Cavern"],
  ["Crystalline Passage", "Frozen River"],
  ["Frozen Tundra", "Infernal Pit"],
  ["Arreat Plateau", "Pit of Acheron"],
  ["Nihlathak's Temple", "Nihlathak", "Halls of Anguish", "Halls of Pain", "Halls of Vaught"],
  ["Ancient's Way", "Icy Cellar"],
  ["Worldstone Keep", "Throne of Destruction", "Worldstone Chamber"],
];

const ZONE_TO_GROUP_KEY = new Map();
const GROUP_KEY_TO_MEMBERS = new Map();
let GROUP_INDEX_BUILT = false;

// Some zone names on the source site appear without their leading article.
// Add explicit aliases here so grouping/theming/display can still resolve correctly.
const ZONE_ALIASES = new Map([
  ["Hole", "The Hole"],
]);

// Optional: custom display labels for zone groups (keyed by GROUP KEY = first item in the group array).
// Example: ["Black Marsh", "The Countess"]
function applyZoneAlias(normName) {
  if (!normName) return normName;
  return ZONE_ALIASES.get(normName) || normName;
}


function normZoneName(s) {
  return (s || "")
    .trim()
    .replace(/\s+/g, " ")
    .replace(/\s*Level\s*\d+$/i, "");
}

function ensureGroupIndexes() {
  if (GROUP_INDEX_BUILT) return;
  GROUP_INDEX_BUILT = true;

  for (const group of (ZONE_GROUPS || [])) {
    if (!group?.length) continue;
    const key = normZoneName(group[0]);
    const members = group.map(normZoneName).filter(Boolean);
    GROUP_KEY_TO_MEMBERS.set(key, members);
    for (const z of members) ZONE_TO_GROUP_KEY.set(z, key);
  }
}

function groupMembersForRawZone(rawZoneName) {
  ensureGroupIndexes();
  const z0 = normZoneName(rawZoneName);
  if (!z0) return [];
  const z = applyZoneAlias(z0);

  const key = ZONE_TO_GROUP_KEY.get(z) || ZONE_TO_GROUP_KEY.get(z0);
  return key ? (GROUP_KEY_TO_MEMBERS.get(key) || []) : [];
}

function groupKeyForRawZone(rawZoneName) {
  ensureGroupIndexes();
  const z0 = normZoneName(rawZoneName);
  if (!z0) return null;
  const z = applyZoneAlias(z0);
  return ZONE_TO_GROUP_KEY.get(z) || ZONE_TO_GROUP_KEY.get(z0) || null;
}


function groupMembersForCanonOrRaw(zoneCanon, rawZoneName) {
  ensureGroupIndexes();
  const canon = normZoneName(zoneCanon);
  if (canon && GROUP_KEY_TO_MEMBERS.has(canon)) return GROUP_KEY_TO_MEMBERS.get(canon) || [];
  return groupMembersForRawZone(rawZoneName);
}

function formatPoolInline(members, fallbackSingle) {
  if (members && members.length) return members.join(", ");
  return normZoneName(fallbackSingle) || "TBD";
}

function formatIncludesFootnote(members) {
  if (!members || members.length <= 1) return "";
  return `\n\n_Includes:_ ${members.join(", ")}`;
}

/* ========================================================================== */
/* ============================ SECTION: ZONE GROUPS END ===================== */
/* ========================================================================== */


/* ========================================================================== */
/* =========================== SECTION: ENTRYPOINTS START ==================== */
/* ========================================================================== */

export default {
  async scheduled(_evt, env, ctx) { ctx.waitUntil(run(env)); },
  async fetch(req, env) {
    const url = new URL(req.url);
    const debug = url.searchParams.get("debug") === "1";
    const out = await run(env, debug);
    return new Response(JSON.stringify(out, null, 2), {
      headers: { "content-type": "application/json" },
    });
  },
};

/* ========================================================================== */
/* ============================ SECTION: ENTRYPOINTS END ===================== */
/* ========================================================================== */


/* ========================================================================== */
/* ============================== SECTION: MAIN START ======================== */
/* ========================================================================== */

async function run(env, debug = false) {
  if (!env || !env.TZ_KV) throw new Error("Missing KV binding TZ_KV");
  const kv = env.TZ_KV;

  const runState = makeRunState();

  const { currentZone, nextZone, diag } =
    await scrapeWithRetry(SCRAPE_MAX_RETRIES, SCRAPE_BASE_DELAY, debug);

  const now = new Date();
  const nowEpoch = Math.floor(now.getTime() / 1000);

  // 30-minute TZ rotation: next boundary is the next :00 or :30 (UTC)
  const utcY  = now.getUTCFullYear();
  const utcMo = now.getUTCMonth();
  const utcD  = now.getUTCDate();
  const utcH  = now.getUTCHours();
  const utcM  = now.getUTCMinutes();

  const nextBoundary = (utcM < 30)
    ? new Date(Date.UTC(utcY, utcMo, utcD, utcH, 30, 0, 0))
    : new Date(Date.UTC(utcY, utcMo, utcD, utcH + 1, 0, 0, 0));

  const epochNext  = Math.floor(nextBoundary.getTime() / 1000);
  const minsToNext = Math.floor((nextBoundary - now) / 60000);
  const stage = stageFor(minsToNext);

  const canonCurrent = canonicalize(currentZone);
  const canonNext    = canonicalize(nextZone);

  // Transient ping housekeeping:
  // - We keep separate "UPCOMING" and "LIVE" transient slots.
  // - We also try to cleanup any legacy single-slot ping pointers if they exist.
  await cleanupLegacyPingPointers(env, nowEpoch);
  await cleanupExpiredPings(env, nowEpoch);

  // Ensure the 2 persistent messages exist and are correctly ordered
  const dashFramed  = frameAnnouncement(buildAnnouncementDashboard());
  const infoContent = buildInfoMessage(currentZone, epochNext, nextZone, epochNext);
  await ensurePersistentPair(env, dashFramed, infoContent);

  // Keep the Info message current (persistent slot #2)
  await ensureInfoMessage(env, { currentZone, nextZone, epochNext });

  // M  // ------------------------------
  // PINGS (centralized, 2-track)
  // ------------------------------
  // We allow up to 2 pings per run:
  // - LIVE slot: when a tracked CURRENT zone becomes live (transition)
  // - UPCOMING slot: discovered / 15min / 5min for tracked NEXT
  //
  // Each slot enforces: delete-before-send. If a delete fails, we keep the ID and retry later.

  const nextDisplayName = canonNext ? displayFor(canonNext) : null;
  const currentDisplayName = canonCurrent ? displayFor(canonCurrent) : null;

  const desired = await computeDesiredPings(env, {
    canonCurrent,
    currentDisplayName,
    canonNext,
    nextDisplayName,
    epochNext,
    minsToNext,
    nowEpoch,
  });

  // Prefer LIVE first (boundary moments), then UPCOMING.
  if (desired.live) {
    await sendPingInSlot(env, "live", desired.live);
  }
  if (desired.upcoming) {
    await sendPingInSlot(env, "up", desired.upcoming);
  }

  // NOTE: LIVE/UPCOMING pings are fully handled by computeDesiredPings + sendPingInSlot.
  // Any legacy LIVE promotion flow has been removed to avoid duplicate/mis-timed pings.

  // Banner behavior (simplified):
  // 1) When no tracked zone is LIVE or NEXT (from the current scrape), show the full dashboard banner.
  // 2) When a tracked zone is LIVE or NEXT, show only the lower border line.
  //
  // We intentionally use the current scrape (canonCurrent/canonNext) so stale KV windows
  // can't keep the banner suppressed.

  const isTrackedNow =
    (!!canonCurrent && WATCH_CANON_MAP.has(canonCurrent)) ||
    (!!canonNext && WATCH_CANON_MAP.has(canonNext));

  const mode = isTrackedNow ? "suppressed" : "dashboard";

  if (mode === "suppressed") {
    await patchAnnouncementOnce(env, runState, frameAnnouncement(buildAnnouncementSuppressed()), "suppressed");
  } else {
    await patchAnnouncementOnce(env, runState, frameAnnouncement(buildAnnouncementDashboard()), "dashboard");
  }

return {
    ok: true,
    currentZone,
    nextZone,
    minsToNext,
    stage,
    diagnostics: debug ? diag : undefined,
  };
}

/* ========================================================================== */
/* =============================== SECTION: MAIN END ========================= */
/* ========================================================================== */


/* ========================================================================== */
/* ===================== SECTION: ANNOUNCE/INFO CONTENT START ================ */
/* ========================================================================== */

function frameAnnouncement(content) {
  return `${(content ?? "").trim()}`;
}

function buildAnnouncementDashboard() {
  const BORDER = "‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óá‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶";

  return [
    BORDER,
    "## TZones are kinda üê∂üí© so‚Ä¶",
    "",
    "### üòà [Sanc](https://maxroll.gg/d2/meta/chaos-sanctuary-farming-guide) ‚Ä¢ üëë [Baal](https://maxroll.gg/d2/meta/worldstone-keep-and-baal-farming-guide) ‚Ä¢ üêÑ [Cows](https://maxroll.gg/d2/meta/the-secret-cow-level-farming-guide) ‚Ä¢ üòà [Ubers](https://maxroll.gg/d2/meta/ubers-explained#why-do-i-farm-hellfire-torches?-header)",
    "### üîë [Keys](https://maxroll.gg/d2/meta/ubers-explained#why-do-i-farm-hellfire-torches?-header) ‚Ä¢ üí∞ [Trav](https://maxroll.gg/d2/meta/travincal-farming-guide) ‚Ä¢ üß™ [Craft](https://maxroll.gg/d2/items/crafted-items) ‚Ä¢ üõ†Ô∏è [Builds](https://maxroll.gg/d2)",
    "",
    BORDER,
  ].join("\n");
}

function buildAnnouncementSuppressed() {
  // "Suppressed" banner = only the lower border line (as per your simplified banner rules)
  const BORDER = "‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óá‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶";
  return BORDER;
}

function buildInfoMessage(currentZone, epochCurrentEnd, nextZone, epochNextStart) {
  const nowEpoch = Math.floor(Date.now() / 1000);
  const BORDER = "‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óá‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶";

  const curCanon = currentZone ? canonicalize(currentZone) : null;
  const nxtCanon = nextZone ? canonicalize(nextZone) : null;

  const curMembers = groupMembersForCanonOrRaw(curCanon, currentZone);
  const nxtMembers = groupMembersForCanonOrRaw(nxtCanon, nextZone);

  const curMain = curCanon ? zoneDisplayForCanon(curCanon) : null;
  const nxtMain = nxtCanon ? zoneDisplayForCanon(nxtCanon) : null;

  const isTrackedLive = !!curCanon && WATCH_CANON_MAP.has(curCanon);
  const isTrackedNext = !!nxtCanon && WATCH_CANON_MAP.has(nxtCanon);

  // ---- LIVE icons ----
  let liveLeftIcon = "‚öîÔ∏è";
  let liveRightIcon = "‚öîÔ∏è";
  if (isTrackedLive) {
    const e = themed(curCanon).header;
    liveLeftIcon = e;
    liveRightIcon = reverseEmojis(e);
  }

  // NEXT icons (keep crystal balls)
  const nextLeftIcon = "üîÆ";
  const nextRightIcon = "üîÆ";

  // ---- LIVE block ----
  const liveName = curMain ? curMain.toUpperCase() : "TBD";
  const liveTitleCore = `${liveLeftIcon} LIVE: ${liveName} ${liveRightIcon}`;
  const liveTitleWrapped = isTrackedLive ? `‚≠ê ${liveTitleCore} ‚≠ê` : liveTitleCore;

  const liveTitle = `## **${liveTitleWrapped}**`;
  const liveEnds  = `### **‚è≥ Ends <t:${epochCurrentEnd}:R> ‚è≥**`;
  const liveZones = `**Zones:** ${curMembers.length ? curMembers.join(", ") : "‚Äî"}`;

  const liveBlock = [liveTitle, liveEnds, liveZones].join("\n");

  // ---- NEXT block ----
  const nextName = nxtMain ? nxtMain.toUpperCase() : "TBD";
  const nextTitleCore = `${nextLeftIcon} NEXT: ${nextName} ${nextRightIcon}`;
  const nextTitleWrapped = isTrackedNext ? `‚≠ê ${nextTitleCore} ‚≠ê` : nextTitleCore;

  const nextTitle  = `## **${nextTitleWrapped}**`;
  const nextStarts = `### **‚è≥ Starts <t:${epochNextStart}:R> ‚è≥**`;
  const nextZones  = `**Zones:** ${nxtMembers.length ? nxtMembers.join(", ") : "‚Äî"}`;

  const nextBlock = [nextTitle, nextStarts, nextZones].join("\n");

  const footer = `_Updated: <t:${nowEpoch}:R>_  [Refresh](https://tz-tracker.csturnbull.workers.dev/)`;

  return [
    liveBlock,
    "",
    BORDER,
    nextBlock,
    "",
    BORDER,
    footer,
  ]
    .join("\n")
    .replace(/\n{3,}/g, "\n\n");
}

/* ========================================================================== */
/* ====================== SECTION: ANNOUNCE/INFO CONTENT END ================= */
/* ========================================================================== */


/* ========================================================================== */
/* ===================== SECTION: PERSISTENT MESSAGE MGMT START ============== */
/* ========================================================================== */

// Discord message IDs are snowflakes; numeric order == creation time order.
function snowflakeLess(a, b) {
  try { return BigInt(a) < BigInt(b); } catch { return String(a) < String(b); }
}

async function ensureInfoMessage(env, { currentZone, nextZone, epochNext }) {
  const kv = env.TZ_KV;
  const id = await kv.get(KV_INFO_ID);
  const content = buildInfoMessage(currentZone, epochNext, nextZone, epochNext);

  if (!id) {
    const newId = await discordPost(env, content);
    if (newId) await kv.put(KV_INFO_ID, newId);
    return;
  }

  const r = await discordPatch(env, id, content);
  if (!r.ok && (r.status === 404 || r.status === 405)) {
    const newId = await discordPost(env, content);
    if (newId) await kv.put(KV_INFO_ID, newId);
  }
}

async function ensurePersistentPair(env, announceContent, infoContent) {
  const kv = env.TZ_KV;

  let announceId = await kv.get(KV_ANNOUNCE_ID);
  let infoId     = await kv.get(KV_INFO_ID);

  const recreateBoth = async () => {
    if (announceId) { try { await discordDelete(env, announceId); } catch {} }
    if (infoId)     { try { await discordDelete(env, infoId); } catch {} }

    const newAnnounceId = await discordPost(env, announceContent);
    const newInfoId     = await discordPost(env, infoContent);

    if (newAnnounceId) await kv.put(KV_ANNOUNCE_ID, newAnnounceId);
    if (newInfoId)     await kv.put(KV_INFO_ID, newInfoId);

    announceId = newAnnounceId || null;
    infoId     = newInfoId || null;
  };

  if (!announceId && !infoId) {
    const lockRes = await withKvLock(kv, "lock:persistent_pair", 30, recreateBoth);
    if (!lockRes.ok) {
      // Another overlapping run is recreating; re-read IDs and return.
      announceId = await kv.get(KV_ANNOUNCE_ID);
      infoId     = await kv.get(KV_INFO_ID);
      return { announceId, infoId };
    }
    return { announceId, infoId };
  }

  if (!announceId && infoId) {
    // Creating announce now would invert order => recreate both.
    const lockRes = await withKvLock(kv, "lock:persistent_pair", 30, recreateBoth);
    if (!lockRes.ok) {
      // Another overlapping run is recreating; re-read IDs and return.
      announceId = await kv.get(KV_ANNOUNCE_ID);
      infoId     = await kv.get(KV_INFO_ID);
      return { announceId, infoId };
    }
    return { announceId, infoId };
  }

  if (announceId && !infoId) {
    // Safe: create info after announce
    const newInfoId = await discordPost(env, infoContent);
    if (newInfoId) {
      await kv.put(KV_INFO_ID, newInfoId);
      infoId = newInfoId;
    }
    return { announceId, infoId };
  }

  if (announceId && infoId && !snowflakeLess(announceId, infoId)) {
    const lockRes = await withKvLock(kv, "lock:persistent_pair", 30, recreateBoth);
    if (!lockRes.ok) {
      // Another overlapping run is recreating; re-read IDs and return.
      announceId = await kv.get(KV_ANNOUNCE_ID);
      infoId     = await kv.get(KV_INFO_ID);
      return { announceId, infoId };
    }
    return { announceId, infoId };
  }

  return { announceId, infoId };
}

/* ========================================================================== */
/* ====================== SECTION: PERSISTENT MESSAGE MGMT END =============== */
/* ========================================================================== */


/* ========================================================================== */
/* ========================= SECTION: TRANSIENT PINGS START ================== */
/* ========================================================================== */

async function cleanupStalePing(env, nowEpoch) {
  const kv = env.TZ_KV;
  const id = await kv.get(KV_LAST_PING_ID);
  if (!id) return;

  const ts = parseInt(await kv.get(KV_LAST_PING_EPOCH) || "0", 10);
  if (!ts) return;

  if (nowEpoch > ts + PING_TTL_SECONDS) {
    try { await discordDelete(env, id); } catch {}
    await kvSoftDelete(kv, KV_LAST_PING_ID, 300);
    await kvSoftDelete(kv, KV_LAST_PING_EPOCH, 300);
  }
}

async function replaceTransientPing(env, content) {
  const kv = env.TZ_KV;
  const nowEpoch = Math.floor(Date.now() / 1000);

  // Guard: if we posted a ping very recently, don't post another.
  // This preserves "hit URL to refresh" but stops double-pings from back-to-back runs.
  const lastTs = parseInt(await kv.get(KV_LAST_PING_EPOCH) || "0", 10);
  if (lastTs && (nowEpoch - lastTs) < 25) return;

  const prevId = await kv.get(KV_LAST_PING_ID);
  if (prevId) { try { await discordDelete(env, prevId); } catch {} }

  const roleId = env.DISCORD_ROLE_ID;
  const allowed_mentions = roleId
    ? { parse: [], roles: [roleId] }
    : { parse: [] };

  const newId = await discordPostWithAllowedMentions(env, content, allowed_mentions);
  if (newId) {
    await kv.put(KV_LAST_PING_ID, newId);
    await kv.put(KV_LAST_PING_EPOCH, String(nowEpoch));
  }
}

function buildLivePing(zoneCanon, zoneDisplay, roleId) {
  const mention = roleId ? `<@&${roleId}> ` : "";
  const theme = themed(zoneCanon);
  const e = theme.header;          // e.g. "üòàüî•"
  const er = reverseEmojis(e);     // reversed, for symmetry (same style as banners)
  return `${mention}‚è≥ ${e} ${zoneDisplay} ${er} ‚è≥`;
}

function buildUpcomingPing(zoneCanon, zoneDisplay, startEpoch, stage, roleId) {
  const mention = roleId ? `<@&${roleId}> ` : "";
  const m = minsUntil(startEpoch);

  const e  = themed(zoneCanon).header;
  const er = reverseEmojis(e);

  // Keep it push-friendly: plain text minutes.
  // Add a little urgency for 5min.
  const bang = (stage === "5min") ? "!" : ".";
  return `${mention}‚è≥ ${e} ${zoneDisplay} ${er} ‚Äî starts in ${m}m${bang} ‚è≥`;
}

/* ========================================================================== */
/* ========================== SECTION: TRANSIENT PINGS END =================== */
/* ========================================================================== */


/* ========================================================================== */
/* ========================= SECTION: UPCOMING & LIVE START ================== */
/* ========================================================================== */

async function patchAnnouncementSlot(env, content) {
  const kv = env.TZ_KV;
  const id = await kv.get(KV_ANNOUNCE_ID);

  if (!id) {
    const newId = await discordPost(env, content);
    if (newId) await kv.put(KV_ANNOUNCE_ID, newId);
    return;
  }

  const r = await discordPatch(env, id, content);
  if (!r.ok && (r.status === 404 || r.status === 405)) {
    const newId = await discordPost(env, content);
    if (newId) await kv.put(KV_ANNOUNCE_ID, newId);
  }
}

function stageFor(mins) {
  // 30-minute rotation => keep only 15/5 windows
  if (mins >= 13 && mins <= 17) return "15min";
  if (mins >= 3  && mins <= 7 ) return "5min";
  return null;
}


/* -------------------------------------------------------------------------- */
/* ----------------------- SECTION: PING MANAGER START ---------------------- */
/* -------------------------------------------------------------------------- */

function pingSlotKeys(slot) {
  if (slot === "live") return { id: KV_PING_LIVE_LAST_ID, epoch: KV_PING_LIVE_LAST_EPOCH };
  return { id: KV_PING_UP_LAST_ID, epoch: KV_PING_UP_LAST_EPOCH }; // default "up"
}

async function cleanupLegacyPingPointers(env, nowEpoch) {
  const kv = env.TZ_KV;

  // If we already migrated, nothing to do.
  const upId = await kv.get(KV_PING_UP_LAST_ID);
  const liveId = await kv.get(KV_PING_LIVE_LAST_ID);

  const legacyId = await kv.get(KV_LAST_PING_ID);
  const legacyTs = parseInt(await kv.get(KV_LAST_PING_EPOCH) || "0", 10);

  // Migrate any legacy pointer to the UPCOMING slot (best-effort).
  if (!upId && !liveId && legacyId) {
    await kv.put(KV_PING_UP_LAST_ID, legacyId);
    if (legacyTs) await kv.put(KV_PING_UP_LAST_EPOCH, String(legacyTs));
    await Promise.all([
      kvSoftDelete(kv, KV_LAST_PING_ID, 300),
      kvSoftDelete(kv, KV_LAST_PING_EPOCH, 300),
    ]);
    return;
  }

  // Keep legacy TTL cleanup for safety (in case the legacy keys linger).
  if (legacyId && legacyTs && nowEpoch > legacyTs + PING_TTL_SECONDS) {
    const ok = await discordDelete(env, legacyId);
    if (ok) {
      await Promise.all([
        kvSoftDelete(kv, KV_LAST_PING_ID, 300),
        kvSoftDelete(kv, KV_LAST_PING_EPOCH, 300),
      ]);
    }
  }
}


async function cleanupExpiredSlot(env, slot, nowEpoch) {
  const kv = env.TZ_KV;
  const { id: idKey, epoch: epochKey } = pingSlotKeys(slot);
  const expKey = (slot === "live") ? KV_PING_LIVE_EXPIRES : KV_PING_UP_EXPIRES;

  const exp = parseInt(await kv.get(expKey) || "0", 10);
  if (!exp || nowEpoch <= exp) return;

  const lastId = await kv.get(idKey);
  if (!lastId) {
    await kvSoftDelete(kv, expKey, 300);
    return;
  }

  const ok = await discordDelete(env, lastId);
  if (!ok) return; // keep ID, retry next run

  await Promise.all([
    kvSoftDelete(kv, idKey, 300),
    kvSoftDelete(kv, epochKey, 300),
    kvSoftDelete(kv, expKey, 300),
  ]);
}

async function cleanupExpiredPings(env, nowEpoch) {
  // LIVE ping cleanup: remove the last LIVE ping after the live window ends (+ grace),
  // but only if it still exists and can be deleted. If delete fails, keep the ID and retry.
  const kv = env.TZ_KV;

  const liveEnd = parseInt(await kv.get("live_end_epoch") || "0", 10);
  if (!liveEnd) return;

  if (nowEpoch <= (liveEnd + LIVE_DELETE_GRACE_S)) return;

  const liveId = await kv.get(KV_PING_LIVE_LAST_ID);
  if (!liveId) return;

  const ok = await discordDelete(env, liveId);
  if (!ok) return;

  const keys = [
    KV_PING_LIVE_LAST_ID,
    KV_PING_LIVE_LAST_EPOCH,
    KV_PING_LIVE_EXPIRES,
    KV_PING_LIVE_CANON,
    "live_zone_canon",
    "live_zone_display",
    "live_start_epoch",
    "live_end_epoch",
  ];

  await Promise.all(keys.map(k => kvSoftDelete(kv, k, 300)));
}

async function acquirePingLock(kv, slot) {
  // Best-effort lock to reduce overlap duplicates.
  // KV is eventual, so this is not perfect, but it helps.
  const key = `lock:ping:${slot}`;
  const existing = await kv.get(key);
  if (existing) return false;
  await kv.put(key, "1", { expirationTtl: 60 });
  return true;
}

async function sendPingInSlot(env, slot, desiredPing) {
  const kv = env.TZ_KV;
  const { id: idKey, epoch: epochKey } = pingSlotKeys(slot);
  const expKey = (slot === "live") ? KV_PING_LIVE_EXPIRES : KV_PING_UP_EXPIRES;

  // Best-effort lock per slot.
  const locked = await acquirePingLock(kv, slot);
  if (!locked) return;

  // If we're sending a LIVE ping for a zone that was previously UPCOMING,
  // delete the UPCOMING slot message first so the LIVE ping becomes the only
  // remaining message for that zone. Enforces delete-before-send across lanes.
  if (slot === "live" && desiredPing && desiredPing.clearUpcoming) {
    const upId = await kv.get(KV_PING_UP_LAST_ID);
    if (upId) {
      const okUp = await discordDelete(env, upId);
      if (!okUp) return; // keep UPCOMING ID, retry next run
    }
    await Promise.all([
      kvSoftDelete(kv, KV_PING_UP_LAST_ID, 300),
      kvSoftDelete(kv, KV_PING_UP_LAST_EPOCH, 300),
      kvSoftDelete(kv, KV_PING_UP_EXPIRES, 300),
      kvSoftDelete(kv, KV_PING_UP_STAGE, 300),
      kvSoftDelete(kv, KV_UP_CANON, 300),
      kvSoftDelete(kv, KV_UP_DISPLAY, 300),
      kvSoftDelete(kv, KV_UP_START_EPOCH, 300),
    ]);
  }

  const lastId = await kv.get(idKey);

  // Enforce delete-before-send. If delete fails, keep ID and retry next run.
  if (lastId) {
    const ok = await discordDelete(env, lastId);
    if (!ok) return;

    await Promise.all([
      kvSoftDelete(kv, idKey, 300),
      kvSoftDelete(kv, epochKey, 300),
      kvSoftDelete(kv, expKey, 300),
    ]);
  }

  if (!desiredPing) return;

  const sentKey = `sent:${desiredPing.key}`;
  if (await kv.get(sentKey)) return;

  const roleId = env.DISCORD_ROLE_ID;
  const allowed_mentions = roleId
    ? { parse: [], roles: [roleId] }
    : { parse: [] };

  const newId = await discordPostWithAllowedMentions(env, desiredPing.content, allowed_mentions);
  if (!newId) return;

  // Record the new transient ping pointer for this slot.
  const nowEpoch = desiredPing.nowEpoch || Math.floor(Date.now() / 1000);
  await kv.put(idKey, newId);
  await kv.put(epochKey, String(nowEpoch));
  if (desiredPing.expiresEpoch) await kv.put(expKey, String(desiredPing.expiresEpoch));

  // Mark sent AFTER success (prevents "claimed-but-never-posted" suppression).
  await kv.put(sentKey, "1", { expirationTtl: desiredPing.sentTtlSeconds || 80 * 60 });

  // Optional success-side KV writes (state tracking).
  if (desiredPing.onSuccessPuts && Array.isArray(desiredPing.onSuccessPuts)) {
    for (const put of desiredPing.onSuccessPuts) {
      if (!put || !put.k) continue;
      if (put.ttl) await kv.put(put.k, put.v, { expirationTtl: put.ttl });
      else await kv.put(put.k, put.v);
    }
  }
}

async function computeDesiredPings(env, { canonCurrent, currentDisplayName, canonNext, nextDisplayName, epochNext, minsToNext, nowEpoch }) {
  const kv = env.TZ_KV;

  const desired = { live: null, upcoming: null };

  const stageRank = (s) => {
    if (s === "disc") return 0;
    if (s === "15min") return 1;
    if (s === "5min") return 2;
    return -1;
  };

  // -----------------------
  // LIVE (tracked CURRENT)
  // -----------------------
  if (canonCurrent && currentDisplayName && WATCH_CANON_MAP.has(canonCurrent)) {
    const liveStart = epochNext - 1800;
    const storedCanon = await kv.get("live_zone_canon");
    const storedStart = parseInt(await kv.get("live_start_epoch") || "0", 10);

    const upCanon = await kv.get(KV_UP_CANON);
    const upStart = parseInt(await kv.get(KV_UP_START_EPOCH) || "0", 10);

    // Transition detected (new live zone or new live window).
    if (storedCanon !== canonCurrent || storedStart !== liveStart) {
      desired.live = {
        key: `live:${liveStart}:${canonCurrent}`,
        // If the UPCOMING lane was tracking the same zone for the same window, clear it before sending LIVE.
        clearUpcoming: (upCanon === canonCurrent && upStart === liveStart),
        content: buildLivePing(canonCurrent, currentDisplayName, env.DISCORD_ROLE_ID),
        nowEpoch,
        sentTtlSeconds: 90 * 60,
        onSuccessPuts: [
          { k: "live_zone_canon", v: canonCurrent },
          { k: "live_zone_display", v: currentDisplayName },
          { k: "live_start_epoch", v: String(liveStart) },
          { k: "live_end_epoch", v: String(epochNext) },
          // legacy/optional marker
          { k: KV_PING_LIVE_CANON, v: canonCurrent, ttl: 6 * 60 * 60 },
        ],
      };
    }
  }

  // --------------------------
  // UPCOMING (tracked NEXT)
  // --------------------------
  if (canonNext && nextDisplayName && WATCH_CANON_MAP.has(canonNext)) {
    const prevCanon = await kv.get(KV_UP_CANON);
    const prevStart = parseInt(await kv.get(KV_UP_START_EPOCH) || "0", 10);
    const prevStage = await kv.get(KV_PING_UP_STAGE) || "";

    // New upcoming target (different from last tracked upcoming): DISCOVERED replaces anything prior.
    if (prevCanon !== canonNext || prevStart !== epochNext) {
      desired.upcoming = {
        key: `up:${epochNext}:${canonNext}:disc`,
        content: buildUpcomingPing(canonNext, nextDisplayName, epochNext, "first", env.DISCORD_ROLE_ID),
        nowEpoch,
        sentTtlSeconds: 90 * 60,
        onSuccessPuts: [
          { k: KV_UP_CANON, v: canonNext },
          { k: KV_UP_DISPLAY, v: nextDisplayName },
          { k: KV_UP_START_EPOCH, v: String(epochNext) },
          { k: KV_PING_UP_STAGE, v: "disc" },
        ],
      };
    } else {
      const stage = stageFor(minsToNext); // "15min" | "5min" | null
      if (stage && stageRank(stage) > stageRank(prevStage)) {
        desired.upcoming = {
          key: `up:${epochNext}:${canonNext}:${stage}`,
          content: buildUpcomingPing(canonNext, nextDisplayName, epochNext, stage, env.DISCORD_ROLE_ID),
          nowEpoch,
          sentTtlSeconds: 90 * 60,
          onSuccessPuts: [
            { k: KV_UP_CANON, v: canonNext },
            { k: KV_UP_DISPLAY, v: nextDisplayName },
            { k: KV_UP_START_EPOCH, v: String(epochNext) },
            { k: KV_PING_UP_STAGE, v: stage },
          ],
        };
      }
    }
  }

  return desired;
}

/* -------------------------------------------------------------------------- */
/* ------------------------ SECTION: PING MANAGER END ----------------------- */
/* -------------------------------------------------------------------------- */

async function maybeAnnounceFirstSeen(env, { zoneCanon, zoneDisplay, startEpoch }, runState) {
  const kv = env.TZ_KV;
  const sentKey = `sent:${startEpoch}:${zoneCanon}:first`;

  // De-dupe
  if (await kv.get(sentKey)) return;

  // CLAIM FIRST to prevent overlap duplicates (cron + manual refresh, etc.)
  await kv.put(sentKey, "1", { expirationTtl: 80 * 60 });

  if (runState) runState.setUpcomingThisRun = true;

  // 2) Send SIMPLE transient ping (one line, push-friendly)
  const pingContent = buildUpcomingPing(zoneCanon, zoneDisplay, startEpoch, "first", env.DISCORD_ROLE_ID);
  await replaceTransientPing(env, pingContent);

  // Keep upcoming metadata for promote->LIVE as before
  await kv.put("upcoming_zone_canon", zoneCanon);
  await kv.put("upcoming_zone_display", zoneDisplay);
  await kv.put("upcoming_start_epoch", String(startEpoch));
}

async function ensureUpcomingAlert(env, { zoneCanon, zoneDisplay, startEpoch, stage }, runState) {
  const kv = env.TZ_KV;
  const sentKey = `sent:${startEpoch}:${zoneCanon}:${stage}`;

  // De-dupe
  if (await kv.get(sentKey)) return;

  // CLAIM FIRST to prevent overlap duplicates
  await kv.put(sentKey, "1", { expirationTtl: 80 * 60 });

  if (runState) runState.setUpcomingThisRun = true;

  // 2) SIMPLE transient ping (one line)
  const pingContent = buildUpcomingPing(zoneCanon, zoneDisplay, startEpoch, stage, env.DISCORD_ROLE_ID);
  await replaceTransientPing(env, pingContent);

  // Keep upcoming metadata for promote->LIVE
  await kv.put("upcoming_zone_canon", zoneCanon);
  await kv.put("upcoming_zone_display", zoneDisplay);
  await kv.put("upcoming_start_epoch", String(startEpoch));
}

function buildUpcomingMessage(zoneCanon, zoneDisplay, startEpoch, stage, role, rawZoneName = null) {
  const theme = themed(zoneCanon);
  const headerLine = `# ${theme.header} ${zoneDisplay} ${reverseEmojis(theme.header)}`;
  const mention = role ? `<@&${role}> ` : "";

  const m = minsUntil(startEpoch);

  let line = "";
  if (stage === "first") {
    const flavor = {
      "Worldstone Keep": "Baal confirmed",
      "Chaos Sanctuary": "Diablo‚Äôs seals loom",
      "The Secret Cow Level": "Herd confirmed",
      "Cathedral": "Andariel confirmed",
      "Tower Cellar": "Countess confirmed",
      "Nihlathak": "Halls confirmed",

      "Tristram": "Tristram confirmed",
      "Dry Hills": "Cube runs confirmed",
      "Lost City": "Lost City confirmed",
      "Arcane Sanctuary": "Sanctuary confirmed",
      "Tal Rasha's Tombs": "Duriel confirmed",

      "Flayer Jungle": "Jungle confirmed",
      "Kurast Bazaar": "Kurast confirmed",
      "Travincal": "Council confirmed",
      "Durance of Hate": "Meph confirmed",

      "Bloody Foothills": "Dodgeball confirmed",
    }[zoneCanon] || "Zone confirmed";

    line = `${mention}${flavor} ‚Äî starts in ${m}m.`;
  } else if (stage === "15min") {
    line = `${mention}‚è≥ starts in ${m}m.`;
  } else {
    // "5min"
    line = `${mention}‚è≥ starts in ${m}m!`;
  }

  const members = groupMembersForCanonOrRaw(zoneCanon, rawZoneName);
  return `${headerLine}\n${line}${formatIncludesFootnote(members)}`;
}

function buildLiveMessage(zoneCanon, zoneDisplay, endEpoch, rawZoneName = null) {
  const theme = themed(zoneCanon);
  const headerLine = `# ${theme.header} ${zoneDisplay} ${reverseEmojis(theme.header)}`;
  const line = `LIVE now ‚Äî ends <t:${endEpoch}:R> @ <t:${endEpoch}:t>.`;
  const members = groupMembersForCanonOrRaw(zoneCanon, rawZoneName);
  return `${headerLine}\n${line}${formatIncludesFootnote(members)}`;
}

async function maybePromoteUpcomingToLive(env, now, { canonCurrentFromScrape, canonNextFromScrape }, runState) {
  const kv = env.TZ_KV;

  const upStart = parseInt(await kv.get("upcoming_start_epoch") || "0", 10);
  const upCanon = await kv.get("upcoming_zone_canon");
  const upDisp  = await kv.get("upcoming_zone_display");
  if (!upStart || !upCanon || !upDisp) return;

  const nowEpoch = Math.floor(now.getTime() / 1000);

  // If we‚Äôre ‚â•4 min after start and still have UPCOMING, broom it.
  if (nowEpoch >= upStart + 4 * 60) {
    const upKeys = ["upcoming_zone_canon", "upcoming_zone_display", "upcoming_start_epoch"];
    await Promise.all(upKeys.map(k => kvSoftDelete(kv, k, 300)));
    return;
  }

  // Promote window: allow some slop around the boundary
  const withinWindow = (nowEpoch >= upStart - 180) && (nowEpoch <= upStart + 300);

  // Compare canonical values directly (no re-canonicalize)
  const nameMatches =
    (!!canonCurrentFromScrape && canonCurrentFromScrape === upCanon) ||
    (!!canonNextFromScrape    && canonNextFromScrape    === upCanon);

  if (!(withinWindow && nameMatches)) return;

  const endEpoch = upStart + 1800;

  // -----------------------------------------
  // De-dupe LIVE promotion ping (missing before)
  // -----------------------------------------
  const sentLiveKey = `sent:${upStart}:${upCanon}:live`;

  // If already sent, do nothing (prevents duplicate LIVE pings)
  if (await kv.get(sentLiveKey)) return;

  // Claim first (best-effort; KV is eventual, but this closes the main hole)
  await kv.put(sentLiveKey, "1", { expirationTtl: 80 * 60 });

  if (runState) runState.setLiveThisRun = true;

  // Brief LIVE ping (hourglasses + display)
  await replaceTransientPing(env, buildLivePing(upCanon, upDisp, env.DISCORD_ROLE_ID));

  // Write LIVE state
  await kv.put("live_zone_canon", upCanon);
  await kv.put("live_zone_display", upDisp);
  await kv.put("live_start_epoch", String(upStart));
  await kv.put("live_end_epoch", String(endEpoch));

  // Clear UPCOMING state (soft delete / blank values)
  const upKeys = ["upcoming_zone_canon", "upcoming_zone_display", "upcoming_start_epoch"];
  await Promise.all(upKeys.map(k => kvSoftDelete(kv, k, 300)));
}

async function maintainLiveAlert(env, now, runState) {
  const kv = env.TZ_KV;

  const endEpoch = parseInt(await kv.get("live_end_epoch") || "0", 10);
  const canon    = await kv.get("live_zone_canon");
  const display  = await kv.get("live_zone_display");

  if (!endEpoch) return;

  const nowEpoch = Math.floor(now.getTime() / 1000);

  if (nowEpoch <= endEpoch) {
    if (runState) runState.setLiveThisRun = true;
    return;
  }

  if (nowEpoch > endEpoch + LIVE_DELETE_GRACE_S) {
    await clearLive(kv);
  }
  // grace window: do nothing
}

async function clearLive(kv) {
  const keys = ["live_zone_canon", "live_zone_display", "live_start_epoch", "live_end_epoch", KV_PING_LIVE_CANON];
  await Promise.all(keys.map(k => kvSoftDelete(kv, k, 300)));
}

/* ========================================================================== */
/* ========================== SECTION: UPCOMING & LIVE END =================== */
/* ========================================================================== */


/* ========================================================================== */
/* =========================== SECTION: DISCORD HTTP START =================== */
/* ========================================================================== */

// Preserve full webhook URL including any query (e.g., ?thread_id=...).
function webhookUrlParts(env) {
  const raw = env?.DISCORD_WEBHOOK_URL;
  if (!raw || typeof raw !== "string" || !/^https?:\/\//i.test(raw)) return null;
  const idx = raw.indexOf("?");
  const path = (idx >= 0 ? raw.slice(0, idx) : raw).replace(/\/+$/, "");
  const qs   = (idx >= 0 ? raw.slice(idx) : "");
  return { path, qs };
}
function withWait(qs) {
  if (!qs) return "?wait=true";
  return qs.includes("wait=true") ? qs : `${qs}&wait=true`;
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

async function fetchWithTimeout(url, init, timeoutMs) {
  const ctl = new AbortController();
  const id = setTimeout(() => ctl.abort(), timeoutMs);
  try { return await fetch(url, { ...init, signal: ctl.signal }); }
  finally { clearTimeout(id); }
}

async function discordFetch(env, url, init, attempts = DISCORD_ATTEMPTS) {
  if (!env?.DISCORD_WEBHOOK_URL) return null;

  let lastResponse = null;
  for (let i = 0; i < attempts; i++) {
    try {
      const r = await fetchWithTimeout(url, init, DISCORD_TIMEOUT_MS);
      lastResponse = r;
      if (r.status !== 429 && r.status < 500) return r; // success or non-retriable
    } catch {
      lastResponse = null; // network error
    }
    if (i < attempts - 1) await sleep(2000);
  }
  return lastResponse;
}

async function discordPostWithAllowedMentions(env, content, allowed_mentions) {
  const parts = webhookUrlParts(env);
  if (!parts) return null;

  const url = parts.path + withWait(parts.qs);
  const r = await discordFetch(env, url, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ content, allowed_mentions, flags: 4 }),
  });

  if (!r || !r.ok) return null;

  try {
    const j = await r.json();
    return j.id || null;
  } catch {
    return null;
  }
}

async function discordPost(env, content) {
  const parts = webhookUrlParts(env);
  if (!parts) return null;

  const url = parts.path + withWait(parts.qs);
  const r = await discordFetch(env, url, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ content, flags: 4 }), // SUPPRESS_EMBEDS
  });

  if (!r || !r.ok) return null;

  try {
    const j = await r.json();
    return j.id || null;
  } catch {
    return null;
  }
}

async function discordPatch(env, messageId, content) {
  const parts = webhookUrlParts(env);
  if (!parts) return new Response(null, { status: 500 });

  const url = `${parts.path}/messages/${messageId}${withWait(parts.qs)}`;
  return await discordFetch(env, url, {
    method: "PATCH",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ content, flags: 4 }),
  });
}

async function discordDelete(env, messageId) {
  const parts = webhookUrlParts(env);
  if (!parts) return false;

  const url = `${parts.path}/messages/${messageId}` + (parts.qs || "");
  const r = await discordFetch(env, url, { method: "DELETE" });

  // Treat "not found" as already-deleted success.
  if (!r) return false;
  if (r.status === 404) return true;
  return !!r.ok;
}

/* ========================================================================== */
/* ============================ SECTION: DISCORD HTTP END ==================== */
/* ========================================================================== */


/* ========================================================================== */
/* ============================ SECTION: SCRAPER START ======================= */
/* ========================================================================== */

async function scrapeWithRetry(maxRetries, baseDelay, debug) {
  let attempt = 0, delay = baseDelay;

  while (attempt <= maxRetries) {
    const res = await fetchWithTimeout(
      SCRAPE_URL,
      { headers: { "user-agent": "tz-worker/1.0" } },
      SCRAPE_TIMEOUT_MS
    );

    if (res.ok) {
      const html = await res.text();
      const { currentZone, nextZone, diag } = extractZones(html);
      if (debug) console.log("diag", diag);
      return { currentZone, nextZone, diag: debug ? diag : undefined };
    }

    let retryMs = delay + Math.floor(Math.random() * delay);
    const hRetry = res.headers.get("Retry-After");
    if (hRetry) {
      const secs = parseFloat(hRetry);
      if (!Number.isNaN(secs)) retryMs = Math.max(retryMs, secs * 1000);
    }
    retryMs = Math.min(retryMs, 2000);

    if (attempt === maxRetries) throw new Error(`scrape failed after retries: ${res.status}`);
    await sleep(retryMs);

    attempt += 1;
    delay = Math.min(delay * 2, 2000);
  }
}

/* ========================================================================== */
/* ============================= SECTION: SCRAPER END ======================== */
/* ========================================================================== */


/* ========================================================================== */
/* ====================== SECTION: PARSER & CANONICALIZER START ============== */
/* ========================================================================== */

function extractZones(html) {
  const rows = html.match(/<tr[^>]*>[\s\S]*?<\/tr>/gi) || [];
  let currentZone = null, nextZone = null;
  let curRowFirstText = null, nextRowFirstText = null;

  for (const row of rows) {
    const firstTd = row.match(/<td[^>]*>([\s\S]*?)<\/td>/i)?.[1];
    if (!firstTd) continue;
    const firstText = stripTags(firstTd).trim().toLowerCase();

    if (!currentZone && /\bcurrent\b/.test(firstText)) {
      curRowFirstText = firstText; currentZone = firstZoneFromRow(row);
    } else if (!nextZone && /\bnext\b/.test(firstText)) {
      nextRowFirstText = firstText; nextZone = firstZoneFromRow(row);
    }
    if (currentZone && nextZone) break;
  }

  return {
    currentZone: currentZone || null,
    nextZone: nextZone || null,
    diag: { curRowFirstText, nextRowFirstText },
  };
}

function firstZoneFromRow(rowHtml) {
  const m = rowHtml.match(/class\s*=\s*"[^"]*z-bone[^"]*"[\s\S]*?>([\s\S]*?)<\//i);
  const t = m ? stripTags(m[1]).trim() : null;
  return t || null;
}

function canonicalize(name) {
  if (!name) return null;

  const n0 = normZoneName(name);
  const n  = applyZoneAlias(n0);

  ensureGroupIndexes();
  const groupKey = ZONE_TO_GROUP_KEY.get(n) || ZONE_TO_GROUP_KEY.get(n0);
  if (groupKey) return groupKey;

  if (/^Countess/i.test(n)) return "Tower Cellar";

  return n;
}

/* ========================================================================== */
/* ======================= SECTION: PARSER & CANONICALIZER END =============== */
/* ========================================================================== */


/* ========================================================================== */
/* =============================== SECTION: UTILS START ====================== */
/* ========================================================================== */

function stripTags(s) {
  return s.replace(/<script[\s\S]*?<\/script>/gi, "")
          .replace(/<style[\s\S]*?<\/style>/gi, "")
          .replace(/<[^>]+>/g, " ")
          .replace(/\s+/g, " ");
}

async function kvSoftDelete(kv, key, ttlSeconds = 300) {
  await kv.put(key, "", { expirationTtl: ttlSeconds });
}

function minsUntil(epochSeconds, nowMs = Date.now()) {
  const diffMs = (epochSeconds * 1000) - nowMs;
  // Floor so we don‚Äôt overstate remaining time
  return Math.max(0, Math.floor(diffMs / 60000));
}

/* ========================================================================== */
/* ================================ SECTION: UTILS END ======================= */
/* ========================================================================== */
